###字符串

javaScript中字符串是固定不变的，类似replace()和toUpperCase()的方法都是返回新的字符串。

###布尔值

以下值布尔值为false：undefined、null、0、-0、NaN、“”

其他值包过对象(数组)都会转换成true，比如**Boolean([])为true**

#####不可变的原始值和可变的对象引用

**JavaScript中的原始值（undefined、null、布尔值、数字和字符串）与对象（包括数组和函数）有着根本区别。原始值是不可更改的：任何方法都无法更改（或“突变”）一个原始值。**JavaScript中的原始值（undefined、null、布尔值、数字和字符串）与对象（包括数组和函数）有着根本区别。原始值是不可更改的：任何方法都无法更改（或“突变”）一个原始值。



#####类型转换

**除了null或undefined之外的任何值都具有toString()方法，这个方法的执行结果通常和String()方法的返回结果一致。**同样需要注意的是，如果试图把null或undefined转换为对象则会像表3-2所描述的那样抛出一个类型错误（TypeError）。Object()函数在这种情况下不会抛出异常：它仅简单地返回一个新创建的空对象。

.toString() 括号中的可以写一个数字，代表进制，对应进制字符串。String()可以将null和undefined转换为字符串，但是没法转进制字符串。

#####隐式转换

JavaScript中的某些运算符会做隐式的类型转换，有时用于类型转换。如果“+”运算符的一个操作数是字符串，它将会把另外一个操作数转换为字符串。一元“+”运算符将其操作数转换为数字。同样，一元“！”运算符将其操作数转换为布尔值并取反。在代码中会经常见到这种类型转换的惯用法：

```javascript
x+ //等价于String(x)
+x //等价于Number(x).也可以写成x-0
!!x //等价于Boolean(x).注意是双叹号
```

如果通过Number()转换函数传入一个字符串，它会试图将其转换为一个整数或浮点数直接量，这个方法只能基于十进制数进行转换，并且不能出现非法的尾随字符。parseInt()函数和parseFloat()函数（它们是全局函数，不从属于任何类的方法）更加灵活。parseInt()只解析整数，而parseFloat()则可以解析整数和浮点数。如果字符串前缀是"0x"或者"0X"，parseInt()将其解释为十六进制数[8]，parseInt()和parseFloat()都会跳过任意数量的前导空格，尽可能解析更多数值字符，并忽略后面的内容。如果第一个非空格字符是非法的数字直接量，将最终返回NaN.“parseInt()可以接收第二个可选参数，这个参数指定数字转换的基数，合法的取值范围是2～36。

#####显式转换

原始值到对象的转换也非常简单，原始值通过调用String()、Number()或Boolean()构造函数，转换为它们各自的包装对象（见3.6节）。

#####原始值转换为对象

原始值到对象的转换也非常简单，原始值通过调用String()、Number()或Boolean()构造函数，转换为它们各自的包装对象（见3.6节）。

##### 对象转为原始值

数组类（Array class）的toString()方法将每个数组元素转换为一个字符串，并在元素之间添加逗号后合并成结果字符串。函数类（Function class）的toString()方法返回这个函数的实现定义的表示方式。实际上，这里的实现方式是通常是将用户定义的函数转换为JavaScript源代码字符串。日期类（Date class）定义的toString()方法返回了一个可读的（可被JavaScript解析的[9]）日期和时间字符串。RegExp类（RegExp class）定义的toString()方法将RegExp对象转换为表示正则表达式直接量的字符串：

 ```javascript
[1,2,3].toString()//=＞"1,2,3"
(function(x){f(x);}).toString()//=＞"function(x){\n f(x);\n}"
/\d+/g.toString()
//=＞"/\\d+/g"
new Date(2010,0,1).toString()//=＞"Fri Jan 01 2010 00:00:00 GMT-0800(PST)
 ```

另一个转换对象的函数是valueOf()。这个方法的任务并未详细定义：如果存在任意原始值，它就默认将对象转换为表示它的原始值。对象是复合值，而且大多数对象无法真正表示为一个原始值，因此默认的valueOf()方法简单地返回对象本身，而不是返回一个原始值。数组、函数和正则表达式简单地继承了这个默认方法，调用这些类型的实例的valueOf()方法只是简单返回对象本身。日期类定义的valueOf()方法会返回它的一个内部表示：1970年1月1日以来的毫秒数。

​	**对象转为字符串：** 先调用toString，如果没有该方法或者返回的不是原始值，再调用valueOf，再没有抛出一个类型错误异常。

​	**对象转为数字：**先调用valueOf，如果没有该方法或者返回的不是原始值，再调用toString，再没有抛出一个类型错误异常。

对于所有非日期的对象来说，**对象到原始值的转换基本上是对象到数字的转换（首先调用valueOf()）**，**日期对象**则使用对象到字符串的转换模式，然而，这里的转换和上文讲述的并不完全一致：通过valueOf或toString()返回的**原始值将被直接使用**，而不会被强制转换为数字或字符串。

“+”、“==”、“!=”运算符以及其他**关系运算符**也会做对象到原始值的转换，但要除去日期对象的特殊情形：任何对象都会首先尝试调用valueOf()，然后调用toString()。不管得到的原始值是否直接使用，它都不会进一步被转换为数字或字符串。其他运算符到特定类型的转换都很明确，而且对日期对象来讲也没有特殊情况。

.toString()可以将所有的的数据都转换为字符串，但是要排除null 和 undefined

String()可以将null和undefined转换为字符串，但是没法转进制字符串

所有的对象（包括数组和函数）都转换为true。对于包装对象亦是如此：new Boolean(false)是一个对象而不是原始值，它将转换为true。

##### 函数作用域和声明提前

在一些类似C语言的编程语言中，花括号内的每一段代码都具有各自的作用域，而且变量在声明它们的代码段之外是不可见的，我们称为块级作用域（block scope），而JavaScript中没有块级作用域。JavaScript取而代之地使用了函数作用域（function scope）：变量在声明它们的函数体以及这个函数体嵌套的任意函数体内都是有定义的。

**ES6 新增了`let`命令，用来声明变量。它的用法类似于`var`，但是所声明的变量，只在`let`命令所在的代码块内有效。**

```javascript
function test(o){
	var i=0;//i在整个函数体内均是有定义的
	if(typeof o=="object"){
		var j=0;//j在函数体内是有定义的，不仅仅是在这个代码段内
        for(var k=0;k＜10;k++){//k在函数体内是有定义的，不仅仅是在循环内
        	console.log(k);//输出数字0～9
        }
		console.log(k);//k已经定义了，输出10
	}
	console.log(j);//j已经定义了，但可能没有初始化
}
```

JavaScript的函数作用域是指在函数内声明的所有变量在函数体内始终是可见的。有意思的是，这意味着变量在声明之前甚至已经可用。JavaScript的这个特性被非正式地称为声明提前（hoisting），即JavaScript函数里声明的所有变量（但不涉及赋值）都被“提前”至函数体的顶部.

```js
var scope="global";
function f(){
    console.log(scope);//输出"undefined"，而不是"global"
    var scope="local";//变量在这里赋初始值，但变量本身在函数体内任何地方均是有定义的
    console.log(scope);//输出"local"
}
```

#####函数声明与函数表达式

**javaScript解析器会在自身作用域内将变量和函数声明提前，**函数声明整个被提前预解析，函数表达式只有变量被提升。

```javascript
foo(){};     // 函数声明
var foo = function(){};    // 函数表达式


foo();         //  函数声明
foo_later();     //  foo_later is not a function

function foo(){ console.log('函数声明'); }
var foo_later = function(){ console.log('函数表达式'); }

//下面代码，变量声明被提到最前（所以不会报出变量不存在的错误），但赋值没有被提前，所以第一次的输出结果是undefined。

function foo(){ console.log('函数声明'); }    // 函数声明全部被提前
var foo_later;     // 函数表达式（变量声明）仅将变量提前，赋值操作没有被提前

foo();             
foo_later();    
foo_later = function(){ console.log('函数表达式'); }
```

